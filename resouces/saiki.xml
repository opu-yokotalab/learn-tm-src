<?xml version="1.0" encoding="utf-8"?>
<xtdl>
  <section title="再帰呼び出し" id="saiki1">
    <section title="再帰呼び出し" id="saiki1.1">
      <explanation title="再帰呼び出しの概要" id="saiki1.1.1">階乗 n! は次のような性質を満たす．<blockquote>n! = n・(n-1)! , 0! = 1</blockquote>ある関数のなかから, 自分自身を呼び出すことを再帰呼び出し (recursive call) という. <br />手続きや関数といった概念を持つプログラミング言語では、ある手続き中で再びその手続き自身を呼び出す事を認める場合が多い。階乗計算やフィボナッチ数列のように、本来再帰的な構造を持つアルゴリズム（再帰的アルゴリズム）を記述するのに適している。<br />再帰のことを帰納という場合もある。</explanation>
      <example title="階乗計算の例" id="saiki1.1.2">再帰プログラムの例として，階乗関数がある．階乗関数 ｎ!は 	<blockquote style="font-weight:bold;">
n!＝1・2・3.....(n-1)・ｎ 
</blockquote>で定義される．このとき、<blockquote style="font-weight:bold;">0! = 1， <br />n &gt; 0　のとき，　n! = (n -1)!・n</blockquote>
と考えることができる． 
      　</example>
      <explanation title="具体的な解説" id="saiki1.1.3">
この考えをもとに３！を計算してみると，次のようになります。 
<blockquote style="font-weight:bold;">3 &gt; 0 だから，　3! = 2! × 3</blockquote>ここで， 2! を計算する。 <blockquote style="font-weight:bold;">2 &gt; 0 だから，2! = 1! × 2</blockquote>ここで 1! を計算する。 <blockquote style="font-weight:bold;">1 &gt; 0 だから，1! = 0! × 1</blockquote>ここで 0! = 1 である。これを使って，上の計算を逆にたどる。 <blockquote style="font-weight:bold;">1! = 0! × 1 = 1 × 1 = 1<br />2! = 1! × 2 = 1 × 2 = 1<br />3! = 2! × 3 = 2 × 3 = 6</blockquote>このようにして 3! が計算されます。 </explanation>
      <example title="C言語による階乗計算の実装例" id="saiki1.1.4">
        <blockquote>
          <pre>/* 階乗n!を計算する */ 
int fact(int n) { 
   /* 脱出条件。0!は1である */ 
   if (n==0)  return 1; 

   /* n!は(n-1)!にnを乗じたもの。再帰呼び出し */
   else return fact(n-1)*n;  
}</pre>
        </blockquote>なお、処理を中断・終了する条件（下の例では引数 n が0である場合）が必ず一つは必要で、その部分が間違っていると無限に関数を呼び出してしまう場合がある.        </example>
      <exercise id="saiki1.1.5-1" title="演習問題">前節で示したプログラムソースに加えて、さらに入力と出力の処理を追加してプログラムを完成させなさい。</exercise>
      <exercise title="模範解答" id="saiki1.1.5-2">以下が模範解答です。<blockquote><pre>// 階乗 n! を計算する
#include&lt;stdio.h&gt;
int fact(int);
int main(void)
{
  int a,n;

  // 変数入力
  printf("input n:");
  scanf("%d",&amp;n);

  // 階乗計算
  a = fact(n);

  // 出力
  printf("answer : %d! = %d\n",n,a);
  return 0;
}
int fact(int n){
  // 基底段階
  if(n == 0) return 1;

  // 帰納段階
  if(n &gt; 0) return n * fact(n-1);
}
</pre></blockquote>上記のプログラムの実行結果です。<blockquote><pre>n として 3 を入力した場合
[******@localhost c]$ ./kaijo
input n:3
answer : 3! = 6

n として 4 を入力した場合
[******@localhost c]$ ./kaijo
input n:4
answer : 4! = 24</pre></blockquote></exercise>
    </section>
    <section title="漸化式での再帰呼び出し" id="saiki1.2">
      <example id="saiki1.2.1" title="漸化式の例">漸化式<blockquote><img src="/~learn/images/zenka.png" width="179"></img></blockquote>できまる数列のn項めをもとめるプログラムを作ろう. <br />プログラムは以下のようになる. 再帰をつかわないプログラムと比べて, ずいぶんすっきりかけていることに注意しよう.<blockquote><pre>int xn2(int n){
  if(n == 0) return 0;
  if(n &gt; 0) return 2*xn2(n-1)+1;
}</pre></blockquote><br />漸化式プログラム自体は単純であるが, 実はこのような場面で再帰をもちいるのはあまり得策ではない.
メモリや実行効率の低下があるからである.<br />関数およびその局所変数は動的に生成, 消滅を繰り返している. たとえば, 上のプログラムで xn2(4) をよぶと, xn2(3), xn2(2), xn2(1), xn2(0) がつぎつぎとよびだされ, xn2(0) の実行中には, 5 つの xn2 が実行されており, したがって局所変数 XN および 引数 N も, それぞれ 5 つ生成されている. したがって一般に, xn2(n) に対しては, 最大 n+1 個の変数領域が確保されることになる.<br />次のようなプログラムを書けば, このようなメモリの無駄使いは生じない.<blockquote><pre>int xn2(int n){
  int i,xn = 0;
  for(i=0;i&lt;n;i++){
    xn = 2*xn+1;
  }
  return xn;
}</pre></blockquote></example>
      <exercise title="演習問題" id="1.2.2-1">上記の例で示したサンプルを用いて、再帰を利用する場合と利用しない場合での、入出力を含めたプログラムを完成させなさい。</exercise>
      <exercise id="saiki1.2.2-2" title="模範解答">以下が模範解答のプログラムリストです。<blockquote />実行結果<blockquote /></exercise>
    </section>
    <section id="saiki1.3" title="フィボナッチ数列">
      <explanation title="フィボナッチ数列" id="saiki1.3.1">フィボナッチの数列 F(n) は次のように定義されている．
<blockquote style="font-weight:bold;"><pre>F(1)=1， F(2)=1
n&gt;2 のとき F(n)=F(n-1)+F(n-2)</pre></blockquote>これによると例えば，F(3)=2, F(4)=3, F(5)=5, F(6)=8, ... となる．このフィボナッチ数はかなり急速に大きくなる数で，例えば F(50)ならば、<blockquote style="font-weight:bold;">

F(50)=12586269025
</blockquote>

となる．
      　</explanation>
      <example title="C言語による実装例" id="saiki1.3.2">
        <blockquote>
          <pre>int Fibonacci(int n) { 
  if (n==0) return 0; 
  else if (n==1) return 1; 
  else return Fibonacci(n-1)+Fibonacci(n-2); 
}</pre>
        </blockquote>なお、処理を中断・終了する条件（下の例では引数 n が0である場合）が必ず一つは必要で、その部分が間違っていると無限に関数を呼び出してしまう場合がある</example>
      <example title="再帰を利用しない実装例" id="saiki1.3.3">
これを再帰を使わずに書くと次のようになります。
<blockquote><pre>int Fibonacci(int n) { 
  int a=1 , b=1 , c;
  int i;
  for(i=3;i＜=n;i++){
    c=a+b;
    b=a;
    a=c;
  }
  return a;
}</pre></blockquote></example>
      <exercise title="演習問題" id="1.3.4-1">上記の例で示したサンプルを用いて、再帰を利用する場合と利用しない場合での、フィボナッチ数を求めるプログラムを入出力を含めた形で完成させなさい。</exercise>
      <exercise id="saiki1.3.4-2" title="模範解答">以下が模範解答のプログラムリストです。<blockquote />実行結果<blockquote /></exercise>
      <explanation title="時間計算量の比較" id="saiki1.3.5">
ここで二つのプログラムの計算量を考えて見ましょう。<br />

フィボナッチ数列の計算量をFB(n)とします。<br />
再帰をつかったプログラムでは、FB(n)=FB(n-1)+FB(n-2)となります。
詳細は省きますが、これをO(n)であらわすと
FB(n)=O(exp^n)となります。
<br />
また、再帰を使わないプログラムでは3からn回までループが一つだけなので、FB(n)=n-3=O(n)となります。<br /><br />
このことからフィボナッチ数列では再帰を使わないほうが計算量が少なく、高速なプログラムといえます。
　　　</explanation>
    </section>
  </section>
  <section title="いろいろな応用" id="saiki2">
    <explanation title="クイックソート" id="quick1">
クイックソートをする関数のサンプルです。<br />
クイックソートとは下記のアルゴリズムを元にしたソートです。<br />
1. 適当な数（ピボットという）を選択する （データの中央値が望ましい） <br />
2. ピボットより小さい数を前方、大きい数を後方に移動させる （分割） <br />
3. 二分割された各々のデータを、それぞれソートする <br /></explanation>
    <explanation title="C言語" id="quick_sample">
      <blockquote>
        <pre>
void qsort(int v[], int left, int right)
{
  int i,last;
  void swap(int v[], int i, int j);

  if(left &gt;= right) return 0;

  swap(v, left, (left + right)/2);
  last = left;
  for(i = left+1; i ＜= right; i++)
    if (v[i] ＜ v[left]) swap(v, ++last, i);
  swap(v, left, last);
  qsort(v, left, last-1);
  qsort(v, last+1, right);
}

void swap(int v[], int i, intj)
{
  int temp;

  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}
</pre>
      </blockquote>
    </explanation>
  </section>
</xtdl>