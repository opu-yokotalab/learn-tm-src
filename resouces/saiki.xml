<?xml version="1.0" encoding="utf-8"?>
<xtdl>
  <section title="再帰呼び出し" id="saiki1">
    <section title="再帰呼び出し" id="saiki1.1">
      <explanation title="再帰呼び出しの概要" id="saiki1.1.1">階乗 n! は次のような性質を満たす．<img src="/~learn/images/kaijo.png" width="179" align="bottom" /><br />ある関数のなかから, 自分自身を呼び出すことを再帰呼び出し (recursive call) という. <br />手続きや関数といった概念を持つプログラミング言語では、ある手続き中で再びその手続き自身を呼び出す事を認める場合が多い。階乗計算やフィボナッチ数列のように、本来再帰的な構造を持つアルゴリズム（再帰的アルゴリズム）を記述するのに適している。<br />再帰のことを帰納という場合もある。</explanation>
      <example title="階乗計算の例" id="saiki1.1.2">再帰プログラムの例として，階乗関数がある．階乗関数 ｎ!は 	<blockquote style="font-weight:bold;">
n!＝１・２・３.....(n-1)・ｎ 
</blockquote>
で定義される．
このとき、
<blockquote style="font-weight:bold;">
0! = 1， <br />
n &gt; 0　のとき，　n! = (n -1)!・n
</blockquote>
と考えることができる． 
      　</example>
      <explanation title="具体的な解説" id="saiki1.1.3">
この考えをもとに３！を計算してみると，次のようになります。 
<blockquote style="font-weight:bold;">
３＞０だから，　３！＝２！＊３　 
</blockquote>

ここで，２！を計算する。 
<blockquote style="font-weight:bold;">
２＞０だから，２！＝１！＊２ 
</blockquote>

ここで１！を計算する。 
<blockquote style="font-weight:bold;">
１＞０だから，１！＝０！＊１ 
</blockquote>

ここで０！＝１である。これを使って，上の計算を逆にたどる。 
<blockquote style="font-weight:bold;">
１！＝０！＊１＝１＊１＝１ <br />
２！＝１！＊２＝１＊２＝１ <br />
３！＝２！＊３＝２＊３＝６ 
</blockquote>

このようにして３！が計算されます。 
      　</explanation>
      <example title="C言語による階乗計算の実装例" id="saiki1.1.4">
        <blockquote>
         /* 階乗n!を計算する */ <br />
         int fact(int n) { <br />
            if (n==0)  return 1; /* 脱出条件。0!は1である */ <br />
            else return fact(n-1)*n; /* n!は(n-1)!にnを乗じたもの。再帰呼び出し */ <br />
         }
</blockquote>なお、処理を中断・終了する条件（下の例では引数 n が0である場合）が必ず一つは必要で、その部分が間違っていると無限に関数を呼び出してしまう場合がある.        </example>
    </section>
    <section title="漸化式の例" id="saiki1.2">
      <example id="saiki1.2.1" title="漸化式の例">
        <div style="left:100px;border:solid gray 3px;width:700px;margin:5px;padding:10px;">漸化式<img src="/~learn/images/zenka.png" width="179"></img>できまる数列のn項めをもとめるプログラムを作ろう. <br />プログラムは以下のようになる. 再帰をつかわないプログラムと比べて, ずいぶんすっきりかけていることに注意しよう.</div>
        <blockquote>
          <pre> def xn2(N) {
    XN = 0;
    for (I=0; I&lt;N; I++) {
      XN = 2*XN+1;
    }
    return(XN);
 }</pre>
        </blockquote>
        <br />漸化式プログラム自体は単純であるが, 実はこのような場面で再帰をもちいるのはあまり得策ではない.
メモリや実行効率の低下があるからである.<br />関数およびその局所変数は動的に生成, 消滅を繰り返している. たとえば, 上のプログラムで xn2(4) をよぶと, xn2(3), xn2(2), xn2(1), xn2(0) がつぎつぎとよびだされ, xn2(0) の実行中には, 5 つの xn2 が実行されており, したがって局所変数 XN および 引数 N も, それぞれ 5 つ生成されている. したがって一般に, xn2(n) に対しては, 最大 n+1 個の変数領域が確保されることになる.<br />次のようなプログラムを書けば, このようなメモリの無駄使いは生じない.</example>
      <explanation title="フィボナッチ数列" id="saiki1.3">フィボナッチの数列 F(n) は次のように定義されている．
<blockquote style="font-weight:bold;">
F(1)=1， F(2)=1， n&gt;2 のとき F(n)=F(n-1)+F(n-2)
</blockquote>
これによると例えば，F(3)=2, F(4)=3, F(5)=5, F(6)=8, ... となる．このフィボナッチ数はかなり急速に大きくなる数で，例えば
<blockquote style="font-weight:bold;">

F(50)=12586269025
</blockquote>

となる．
      　</explanation>
      <example title="C言語による実装例" id="saiki1.3.2">
        <blockquote>
int Fibonacci(int n) { <br />
  if (n==0) return 0; <br />
  else if (n==1) return 1; <br />
  else return Fibonacci(n-1)+Fibonacci(n-2); <br />
}
</blockquote>なお、処理を中断・終了する条件（下の例では引数 n が0である場合）が必ず一つは必要で、その部分が間違っていると無限に関数を呼び出してしまう場合がある        </example>
      <example title="再帰を利用しない実装例" id="saiki1.3.3">
これを再帰を使わずに書くと次のようになります。
<blockquote>
int Fibonacci(int n) { <br />
  int a=1 , b=1 , c;<br />
  int i;<br /><br />
  for(i=3;i＜=n;i++){<br />
    c=a+b;<br />
    b=a;<br />
    a=c;<br />
  }<br /><br />
  return a;<br />
}
</blockquote></example>
      <explanation title="時間計算量の比較" id="saiki1.3.3_1">
ここで二つのプログラムの計算量を考えて見ましょう。<br />

フィボナッチ数列の計算量をFB(n)とします。<br />
再帰をつかったプログラムでは、FB(n)=FB(n-1)+FB(n-2)となります。
詳細は省きますが、これをO(n)であらわすと
FB(n)=O(exp^n)となります。
<br />
また、再帰を使わないプログラムでは3からn回までループが一つだけなので、FB(n)=n-3=O(n)となります。<br /><br />
このことからフィボナッチ数列では再帰を使わないほうが計算量が少なく、高速なプログラムといえます。
　　　</explanation>
    </section>
  </section>
  <section title="クイックソート" id="quick">
    <explanation title="テキスト" id="sample1.3.1">
クイックソートをする関数のサンプルです。<br />
クイックソートとは下記のアルゴリズムを元にしたソートです。<br />
1. 適当な数（ピボットという）を選択する （データの中央値が望ましい） <br />
2. ピボットより小さい数を前方、大きい数を後方に移動させる （分割） <br />
3. 二分割された各々のデータを、それぞれソートする <br /></explanation>
    <explanation title="C言語" id="saiki_sample1.3.2">
      <div style="font-size:13pt;">
        <pre>
void qsort(int v[], int left, int right)
{
  int i,last;
  void swap(int v[], int i, int j);

  if(left &gt;= right) return 0;

  swap(v, left, (left + right)/2);
  last = left;
  for(i = left+1; i ＜= right; i++)
    if (v[i] ＜ v[left]) swap(v, ++last, i);
  swap(v, left, last);
  qsort(v, left, last-1);
  qsort(v, last+1, right);
}

void swap(int v[], int i, intj)
{
  int temp;

  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}
</pre>
      </div>
    </explanation>
  </section>
</xtdl>